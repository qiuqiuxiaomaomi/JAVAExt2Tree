# JAVAExt2Tree
Java高级基础技术研究


<pre>
Java中如何正确的终止线程：

      1）Thread.stop()
         一个被废弃了的方法，不被推荐使用的原因是stop方法太过于暴力，强行把执行到一半的线
         程终止，并且会立即释放这个线程所有的锁，会破坏了线程中引用对象的一致性。

         例如在数据库中维护着一张用户表，记录了用户ID和用户名，使用Thread多线程写入两条记录:

             如果在记录1写到一半的时候被stop结束了，就可能出现各种奇怪的现象：

             记录1被记录2覆盖，没有任何数据留下。

             记录1只有一半，即只有ID，而NAME为空。

      使用判断标志位的方法中断线程：
          那如果的确有中断线程的需求,我们需要怎么做呢？一般我们马上就会想到设置标志位的方
          法,即在线程中执行每一个步骤之前都判断一下是否需要退出线程:
          
          其实Thread类早就帮我们实现了这个中断标志了。与Thread中断相关的方法有下面三个:
               public void Thread.interrupt() //线程中断

               public native boolean Thread.isInterrupted() //判断是否被中断

               public static native boolean Thread.interrupted() //判断是否中断,并清除当前中断状态

          需要提醒一下的是Thread.interrupt()方法并不会像Thread.stop()方法一样立即结束
          线程,它只是设置了一个中断标志,需要在代码实现中去手动判断这个标志并且推出。

          Thread.interrupt的优点
              使用Thread.interrupt去中断线程除了可以免去自己实现标志位的烦恼之外,还可以中断sleep和wait中的线程。

              需要注意的是如果sleep方法由于中断而抛出异常，此时，它会清除中断标记。所以在
              catch到这个异常的时候需要再次设置中断标记：
</pre>

<pre>
内连接 左连接 右连接 全连接

      left join:  返回包括左表中的所有记录和右表中连接字段相等的记录
      right join :返回右表中的所有记录和左表中和连接字段相等的记录
      inner join: 只返回两个表中连接字段相等的行
      full join: 返回左右表中所有的记录和左右表中连接字段相等的记录
</pre>

![](https://i.imgur.com/AZNAwBy.png)

![](https://i.imgur.com/Z6ZQYN9.png)

<pre>
SQL注入的原理

      解决方法：
              1）永远不要信任用户的输入，要对用户的输入进行校验，能够通过正则表达式，或
                 限制长度，对单引号和双-进行转换等。
              2）永远不要使用动态拼装SQL,能够使用参数化的SQL或者直接使用存储过程进行数据
                 查询存取
              3）永远不要使用管理员权限的数据库连接，为每一个应用使用单独的权限有限的数据库连接。
              5）不要把机密信息明文存放，请加密或者hash掉password和敏感的信息
              6）应用的异常信息应该给出尽可能少的提示，最好使用自己定义的错误信息对原始
                 错误信息进行包装，把异常的信息存放在独立的表中。

      但使用正則表達式仅仅能防范一些常见或已知SQL Injection方式，并且每当发现有新的攻击方
      式时，都要对正則表達式进行改动，这但是吃力不讨好的工作。
  
      可以通过參数化存储过程进行数据查询存取。

      大家看到当我们试图在URL中嵌入恶意的SQL语句时，參数化存储过程已经帮我们校验出传递给数
      据库的变量不是整形，并且使用存储过程的优点是我们还能够非常方便地控制用户权限，我们能
      够给用户分配仅仅读或可读写权限。

      但我们想想真的有必要每一个数据库操作都定义成存储过程吗？并且那么多的存储过程也不利于
      日常的维护。           
</pre>

<pre>
10万并发的服务器应该怎么构建？

      首先要确认你的10w并发服务器，是长连接型的，如即时通讯；还是短连接型的，如网站？

      如果是短连接型，首推仍然是线程池；因为这种情况下连接会很多、切换很快，所以没必要去维护
      连接，想想银行大厅的前台窗口排队叫号，窗口忙得很如果还同时照顾几个客户那不疯了？

      如果是长连接型，首推是NIO模型；因为这种情况下保持连接很重要，但线程并不忙，想想医院住
      院部的病人，大部分时间躺在床上就行了，一个护士就可以搞定好多病人了；mina提供了比较好
      的封装。
</pre>

<pre>
缓存击穿有哪些方案解决?
</pre>

<pre>
dubbo如何一条链接并发多个调用
</pre>

<pre>
Override和Overload的区别，分别用在什么场景

      override是方法覆盖，用在父子类中，是方法名字相同，参数列表也相同，声明形式都相同，但
      是子类方法的权限不允许小于父类，不允许抛出比父类更多的异常。调用子类的方法与父类的同名
      方法无关，在子类中完全覆盖了父类的方法。

      overload是方法重载，用在同一个类中，是几个方法的名字相同，返回值相同，但是参数列表不
      同，举例来说就像构造函数，可以有多个构造函数，并且每个的参数列表都不同，这样可以用多
      种方式构造对象。
</pre>

<pre>
类序列化时类的版本号的用途，如果没有指定一个版本号，系统是怎么处理的？如果加了字段会怎么样？

      Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反
      序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的
      serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序
      列化版本不一致的异常。

      serialVersionUID 用来表明类的不同版本间的兼容性。有两种生成方式： 
          1) 一个是默认的1L；
          2) 另一种是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段 。 在JDK
          中，可以利用JDK的bin目录下的serialver.exe工具产生这个serialVersionUID 的值

          对于Test.class，
               执行命令： 
                       serialver Test   
               这时JVM（java虚拟机）会生成一个哈希字段。
</pre>

<pre>
InnoDB读不加锁
</pre>

<pre>
mybatis如何映射表结构
</pre>

<pre>
static加锁

      synchronized与static synchronized 的区别
     
          synchronized是对类的当前实例进行加锁，防止其他线程同时访问该类的该实例的所有
          synchronized块，注意这里是“ 类的当前实例 ”，类的两个不同实例就没有这种约束
          了。

          那么static synchronized恰好就是要控制类的所有实例的访问了，static 
          synchronized是限制线程同时访问jvm中该类的所有实例同时访问对应的代码块。实际
          上，在类中某方法或某代码块中有 synchronized，那么在生成一个该类实例后，该类
          也就有一个监视块，放置线程并发访问该实例synchronized保护块， 而 static 
          synchronized 则是所有该类的实例公用一个监视块了 ，也就是两个的区别了,也就是
          synchronized相当于this.synchronized，而staticsynchronized相当于
          Something.synchronized.
</pre>

<pre>
sql语句各种条件的执行顺序，如select， where， order by， group by
</pre>

<pre>
mysql是如何实现事务的
</pre>

<pre>
hashmap如果只有一个写其他全读会出什么问题
</pre>

<pre>
如何手动触发全量回收垃圾，如何立即触发垃圾回收

      强制触发垃圾回收方法
          1) 调用System类的gc()静态方法：System.gc();
          2) 调用Runtime对象的gc()实例方法：Runtime.getRuntime().gc();
</pre>

<pre>
ConcurrentHashmap的锁是如何加的？是不是分段越多越好

      ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重
      入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值
      对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类
      似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是
      一个链表结构的元素， 每个Segment守护者一个HashEntry数组里的元素,当对HashEntry数
      组的数据进行修改时，必须首先获得它对应的Segment锁。

      并不是分段越多越好:
          有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而
      不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。这里“按
      顺序”是很重要的，否则极有可能出现死锁，在ConcurrentHashMap内部，段数组是final
      的，并且其成员变量实际上也是final的，但是，仅仅是将数组声明为final的并不保证数组
      成员也是final的，这需要实现上的保证。这可以确保不会出现死锁，因为获得锁的顺序是固定
      的。
</pre>

<pre>
mysql的行级锁加在哪个位置
</pre>

<pre>
遍历hashmap的三种方式
</pre>

![](https://i.imgur.com/VhNI4yo.png)

![](https://i.imgur.com/7kFMoWw.png)

<pre>
定时器用什么做的
</pre>

![](https://i.imgur.com/2X02mb8.png)

![](https://i.imgur.com/gnonM4h.png)

<pre>
用过spring的线程池还是java的线程池？

      SpringFrameWork 的 ThreadPoolTaskExecutor 是辅助 JDK 的 ThreadPoolExecutor 的工具类，它将属性通过 
      JavaBeans 的命名规则提供出来，方便进行配置

      Spring线程池：
                  ThreadPoolTaskExecutor 
      Java线程池：
                  ThreadPoolExecutor 
</pre>

<pre>
IO会阻塞吗？readLine是不是阻塞的
</pre>

<pre>
spring的监听器。
</pre>

<pre>
spring的bean配置的几种方式
</pre>

<pre>
aop的底层实现，动态代理是如何动态，假如有100个对象，如何动态的为这100个对象代理
</pre>

<pre>
一万个人抢100个红包，如何实现（不用队列），如何保证2个人不能抢到同一个红包，可用分布式锁
</pre>

![](https://i.imgur.com/mutHYAJ.png)

![](https://i.imgur.com/Ashw3kj.png)

<pre>
Java抢红包算法
</pre>

<pre>
线程的阻塞的方式
</pre>

<pre>
用hashmap实现redis有什么问题（死锁，死循环，可用ConcurrentHashmap）
</pre>

![](https://i.imgur.com/79z7L3r.png)

![](https://i.imgur.com/6MqWLs7.png)

![](https://i.imgur.com/jCY9G8L.png)

![](https://i.imgur.com/U12dn6j.png)

<pre>
nginx的请求转发算法，如何配置根据权重转发
</pre>

![](https://i.imgur.com/EMANTt2.png)

<pre>
junit用法，before,beforeClass,after, afterClass的执行顺序

     JUnit4使用Java5中的注解（annotation），以下是JUnit4常用的几个annotation： 
         @Before：初始化方法   对于每一个测试方法都要执行一次（注意与BeforeClass区别，
                 后者是对于所有方法执行一次）
         @After：释放资源  对于每一个测试方法都要执行一次（注意与AfterClass区别，后者
                 是对于所有方法执行一次）
         @Test：测试方法，在这里可以测试期望异常和超时时间 
         @Test(expected=ArithmeticException.class)检查被测方法是否抛出
              ArithmeticException异常 
         @Ignore：忽略的测试方法 
         @BeforeClass：针对所有测试，只执行一次，且必须为static void 
         @AfterClass：针对所有测试，只执行一次，且必须为static void 
          
      一个JUnit4的单元测试用例执行顺序为： 
           @BeforeClass -> @Before -> @Test -> @After -> @AfterClass; 
      每一个测试方法的调用顺序为： 
           @Before -> @Test -> @After; 
</pre>

<pre>
Mysql的三大存储引擎
</pre>

![](https://i.imgur.com/MshlYam.png)

![](https://i.imgur.com/oDCIr0U.png)

![](https://i.imgur.com/HGUsOYI.png)

![](https://i.imgur.com/cpK8UNJ.png)

![](https://i.imgur.com/ZmQi99k.png)

<pre>
redis的hash算法用的是啥？

      redis使用的consistent hashing(一致性hash算法)
</pre>

<pre>
nosql为啥比sql快？

      1) 扩展困难：由于存在类似Join这样多表查询机制，使得数据库在扩展方面很艰难;

      2) 读写慢：这种情况主要发生在数据量达到一定规模时由于关系型数据库的系统逻辑非常复杂，
                使得其非常容易发生死锁等的并发问题，所以导致其读写速度下滑非常严重;

      3) 成本高：企业级数据库的License价格很惊人，并且随着系统的规模，而不断上升;

      5) 有限的支撑容量：现有关系型解决方案还无法支撑Google这样海量的数据存储;
</pre>

<pre>
Java事件机制包括哪三个部分？
</pre>

<pre>
反射机制会不会有性能问题？

      反射大概比直接调用慢50~100倍，但是需要你在执行100万遍的时候才会有所感觉
      判断一个函数的性能，你需要把这个函数执行100万遍甚至1000万遍
      如果你只是偶尔调用一下反射，请忘记反射带来的性能影响
      如果你需要大量调用反射，请考虑缓存。
      你的编程的思想才是限制你程序性能的最主要的因素
</pre>

![](https://i.imgur.com/z7Fl5N3.png)

![](https://i.imgur.com/EhbASc2.png)

<pre>
说说http协议的工作流程。

      1 . 地址解析
       HTTP协议是通过标准URL来请求指定的服务器中指定服务的 . 一个标的 URL 如下 :
           http://www.baidu.com:80/index.html?name=tom&age=18.
 
       下面来解析一下 URL , 看看这些组成都是做什么的 :
       (1) http: 协议类型 . 这里指的是要发送的是什么协议，还可以是FTP等其他协议 . 而这
                 里请求的是服务器中的网页，所以使用的是常见的HTTP协议 .
       (2) www.baidu.com：主机名 . 通过主机名，可以准确定位到要访问的那台服务器 . 而在
             前面说的网络通信中，IP是可以唯一表示服务器地址的，但IP烦琐复杂，很难记忆，所
             以人们就想了个办法，通过熟悉的英文、数字等来表示一台服务器的地址，称为域名。这
             样就需要一个文件（作为一个数据仓库）把IP和域名一一对应起来 . 在很早的时候，
             我们确实是这么做的，不过随着IP越来越多，文件也变得越来越大，不堪负重 . 于是
             人们就想到了把这些一一对应的关系都放到一台统一的服务器上，这台服务器被称为
             DNS域名解析系统，它会把域名解析成对应的IP .
       (3) 80：端口号 . 用户已经可以通过域名或者IP访问到一台服务器了，但是一台服务器里有
             那么多的服务和应用，怎样才能准确找到用户需要访问的那个服务或应用呢？在服务器
             中，每个服务和应用都会开启一个进程，都会有一个进程号（PID），如果对外提供服
             务，则还会有一个唯一的端口号，这让外部应用可以直接通过这个端口号访问到指定的
             服务和应用。端口号的范围是0～65 535，一些常用的服务和应用都有默认的端口号，
             一般不能轻易更改，比如Web服务器的80端口、远程连接SSH服务的22端口、数据库
             MySQL的3306端口等等。因为80端口是Web服务器的默认端口，所以在写HTTP请求的
             URL的时候，80端口一般是省略的 .
       (4) index.html：请求的文件名 . 用户通过域名和端口号已经能访问到Web服务器了，接下
             来就可以通过文件名来访问指定的文件了 . Web服务器一般都做好了路由，不同的路由
             所提供的访问文件的形式可能不一样，但核心都是一样的 .
       (5)  ?name=tom&age=18：请求参数 . 即使同一个网页，可能针对不同的用户，服务器要返
             回给客户端的信息也是不一样的 . 而服务器就是通过URL中“?”后面携带的参数不同来
             响应不同的用户或者同一个用户的不同请求的 .
      2 . 封装HTTP 请求
          这一步把上面写的 URL 以及本机的一些信息封装成一个 HTTP 请求数据包
      3 . 封装 TCP 包
          第三步就是封装 TCP 包 , 建立 TCP 连接 , 也就是常说的"三次握手" . 由于HTTP位
          于最上层的应用层 , 所以HTTP在工作之前要由 TCP 和 IP 协议建立网络连接 , 这就是
          TCP/IP协议族 , 因此互联网又称为 TCP/IP 网络 .
          这里就少TCP/IP协议的"三次握手" , 首先由客户端发送建立连接的请求 , 客户端发送一
          个 syn 包 , 等待服务端的响应 ; 服务端收到 syn 包之后 , 返回给客户端一个表示确
          认的 syn 包 和 ack 包 , 最后客户端收到之后向服务端发送 ACK 包 , 发送完之后开
          始建立连接 , 如下图所示

      4 . 客户端发送请求命令
          第四步就是在连接建立之后 , 客户端发送 HTTP 请求到服务端与请求相关的信息都会包含在
          请求头和请求体中发送给服务器端 .
      5 . 服务器端响应
          服务器端在收到请求之后  , 根据客户端的请求发送给客户端相应的信息 , 相关的响应信息
          都会放在响应头和响应体中 .

    关闭连接
       服务器端在发送完响应之后 , 就会关闭连接 , 如果过客户端的请求的头部信息中有 
       Connection-alive , 那么客户端在响应完这个请求之后不会关闭连接 , 知道客户端的所有请
       求都响应完毕 , 才会关闭连接 , 这样大大节省了带宽和 IO 资源 .


    请求和响应
       HTTP请求室友两部分组成 : HTTP消息头和 HTTP消息体 . 消息头告诉服务器该请求是做什么的,
       消息体高速服务器怎么做 , 比如访问一个网页 , 头部信息可以到浏览器中的调试中心看 , 而消
       息体需要用户单机鼠标右键查看源码 , 那些HTML代码就是服务器返回给客户端的消息体 .

        1) 请求行
          请求的第一行是请求行 , 里面有请求方法 , URL , 协议版本等 , 比如上图中 , 请求的方
          法是 GET , 请求的URL是/ , 协议版本是HTTP/1.1 .

          常见的请求方式有GET 和 POST , GET 方式主要用于请求网络资源 , POST 方式主要用于表
          单提交 , 由于GET方式的参数是在地址栏中的  , 所以总是可见的 , 不是很安全 , 而且长度
          也有限制 (2048个字符) , 而 POST 方式的参数是封装成实体之后发送给服务器的 , 是不可
          见的 , 相对比较安全 , 用户的敏感信息一般采用post  方式提交 .

        2) 请求头
          每个头域都由一个头域名 , 冒号和值域组成 , 下面介绍一些最常见的头域 :
             (1) Connection : 表示是否需要持久连接 , 如果服务器看到它的值为 keep-alive ,
             或者请求协议使用的是HTTP/1.1(默认使用持久连接) , 同一个页面如果包含多个资源 ,
             则只会使用一个连接 , 如Connection : keep-alive . 如果设置了 

                 Connetion:close , 则每一个请求结束都会关闭连接 , 新的请求又会重新建立连
                           接 , 一个网页至少有几十个资源请求 , 这样会浪费带宽和时间 .
             (2) Host : 这个是必需的 , 表示请求的服务器地址是什么 , 是从URL 中提取出来的 .
                    比如 http://www.baidu.com/ 的host 就是 www.baidu.com , 这里是80端
                    口 , 默认省略 ; 如果是其他端口 , 比如 http://www.baidu.com:8080 , 
                    则Host是 www.baidu.com:8080 .
             (3) Accept : 浏览器可以接受的媒体类型(MIME) , 如 Accept:text/html 代表可
                     以接受HTML文档 , " * "代表接受任何类型 , 如 Accept:/ .
             (4) Accept-Encoding : 浏览器申明自己接受的编码方法 , 通常指定压缩方法 , 是
                     否支持压缩 , 支持什么格式的压缩 .
         3) 请求正文
            也叫请求数据 , 在使用post请求表单数据的时候 , 这些表单数据就会被放在 HTTP 请求
            的请求正文中 , 以加密的形式向服务器传输 .
</pre>

<pre>
说说Java虚拟机的生命周期及体系结构。
</pre>

<pre>
分布式系统你会考虑哪些方面？

     1) 异构性
        分布式系统由于基于不同的网络，操作系统，计算机硬件和编程语言来构造，必须要考虑一种通用
        的网络协议来屏蔽异构系统之间的差异，一般交由中间件来处理这些差异。
     2）缺乏全球时钟
        在程序需要协作时，他们通过交换消息来协调他们的动作，紧密的协调经常依赖于对程序动作发生
        时间的共识，但是实际上网络上计算机同步时钟的准确性受到极大的限制，即没有一个正确时间的
        全局概念，这是通过网络发送消息作为唯一的通信方式这一事实带来的直接结果。
     3）一致性
        数据被分散或者复制到不同的机器上，如果保证各台主机之间数据的一致性将成为一个难点。
     5）故障的独立性
        任何计算机都有可能发生故障且各种总故障不尽相同，他们之间出现故障的时间也是相互独立的，
        一般分布式系统要设计成允许部分故障，而不影响整个系统的正常使用。
     6）并发
        分布式系统的目的是更好的共享资源，那么系统中的每个资源都必须被设计成在并发环境中安全的。
     7）透明性
        分布式系统中任何组件的故障，或者主机的升级和迁移对于用户来说是透明的，不可见的。
     8）开放性
        分布式系统由不同的程序员来编写不同的组件，组件最终要集成为一个系统，那么组件锁发布的接
        口必须遵守一定的规范且能够被相互理解。
     9）安全性
        在网络上所有传递的敏感信息都要加密，拒绝服务攻击任然是一个有待解决的问题。
     10）可扩展性
        系统要设计成随着业务量的增加，相应的系统也必须要扩展来提高对应的服务。
</pre>

<pre>
什么是检查异常，不受检查异常，运行时异常？并分别举例说明。
     在Java中，一般异常有两种实现模型，一种是（Checked Exception）受控异常；另一种是
     （Runtime Exception）非受控异常。受控异常，是指那些需要在客户显式捕获、处理或抛出的
     异常，它们继承自java.lang.Exception；运行时异常，是指不需要客户显式捕获、处理或抛
     出的异常，它们继承自Java.lang.RuntimeException。


     受控异常：Checked Exception，这类异常必须写try{}catch{}，或者throw抛出，否则编
             译通不过。

     非受控异常：
             Unchecked Exception，这类异常也叫做运行时异常（与非受控异常 字数相等），
             这类异常不需要try{}catch{}，也不需要throw抛出，编译能通过。为什么要使用非
             受控异常？为了简化代码。试想一下，如果所有可能出现异常的地方（比如访问数组
             元素可能会越界、调用对象方法，对象可能为null），我们都写try{}catch{}，或
             者throw 抛出，那么代码肯定冗余的不成样子了。也就是说，采用非受控异常（运行
             时异常）可以减少代码的污染。

     对于非受控异常（运行时异常），因为不需要额外处理，也能编译通过，我们可以进行预先
     检查，比如访问数组元素时，我们预先检查是否越界，调用对象方法时，预先检查对象是否为null
</pre>

这是因为这两个例子都在try代码块之前就结束了temp()方法，try代码块并没有得到执行，
所以finally中的代码块也不会得到相应的执行。只有在try代码块得到执行的情况下，finally代码
块才会得到执行。
![](https://i.imgur.com/0X18WVG.png)

执行结果为：可以看到只打印了try代码块中的语句，finally代码块中的语句并没有打印，这是因
为System.exit(0);它表示退出当前Java虚拟机，一旦退出Java虚拟机，任何代码都不会再执行。
![](https://i.imgur.com/nURYpzW.png)


写程序一般都不会写System.exit(0)；来退出Java虚拟机，那么是不是不写System.exit(0)；
finally代码块就一定会得到执行呢？
可能还是会让你们失望了，答案时不一定的，这又是为什么？来看这段文字，估计你应该会明白一些。
如果当一个线程在执行 try 语句块或者 catch 语句块时被打断（interrupted）或者被终止
（killed），与其相对应的 finally 语句块可能不会执行。还有更极端的情况，就是在线程运行 
try 语句块或者 catch 语句块时，突然死机或者断电，finally 语句块肯定不会执行了。


<pre>
finally块一定会执行吗？
</pre>

<pre>
Java虚拟机中，数据类型可以分为哪几类？
      1）基本类类型 byte,short,int,long,char,float,double,Boolean,returnAddress
      2）引用类型  类类型，接口类型和数组。
</pre>

![](https://i.imgur.com/LYql4Wx.png)

<pre>
在Java中，什么是是栈的起始点，同是也是程序的起始点？

      程序要运行总是有一个起点的。同C语言一样，java中的Main就是那个起点。无论什么java
      程序，找到main就找到了程序执行的入口。
</pre>

<pre>
为什么要把堆和栈区分出来呢？栈中不是也可以存储数据吗？

      1）从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据，这样分开，使得处理逻辑
         更为信息，分而治之的思想，这种隔离，模块化的思想在软件设计的方方面面都有体现。
      2）堆与栈的分离，使得堆中的内容可以被多个栈共享，这种共享的收益是很多的，一方面
         这种共享提供了一种有效的数据交互方式，另一方面，堆中的共享常量和缓存可以被所有
         线程栈访问，节省了空间。
      3）栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分，由于栈
         只能向上增长，因此就会限制栈内存内容的能力，而堆不同，堆中的对象是可以根据需要
         动态增长的，因此栈和堆的拆分，使得动态增长成为可能,相应栈中只需要记录堆中的一个
         地址即可。
      5）面向对象就是堆和栈的完美结合，其实，面向对象方式的程序与以前结构化的程序在执行
         上没有任何区别，对象的数据属性存放在堆中，对象的存取逻辑放在栈中。
</pre>

<pre>
Java中的参数传递时传值呢？还是传引用？

      （1）基本数据类型传值，对形参的修改不会影响实参；
      （2）引用类型传引用，形参和实参指向同一个内存地址（同一个对象），所以对参数的修改
           会影响到实际的对象；
      （3）String, Integer, Double等immutable的类型特殊处理，可以理解为传值，最后
          的操作不会修改实参对象。
</pre>

<pre>
Java中，栈的大小通过什么参数来设置？

      -Xss256K: 设置每个线程的运行时栈的大小为 256K。
     
      -Xmx，设置JVM最大内存；比如 -Xmx512M: 设置JVM最大内存为512M；
      -Xms，设置JVM最小内存；比如 -Xms512M: 设置JVM最小内存为512M；
      -Xmn，设置JVM年轻代内存；比如 -Xmn1G：设置年轻代内存为 1 G。

      具体设置：
              java -Xss512K -jar xxx.jar
</pre>

<pre>
一个空Object对象的占多大空间？
</pre>

<pre>
如何解决JVM内存碎片的问题？

      内存碎片通常分为内部碎片和外部碎片：
          1、内部碎片由于采用固定大小的内存分区、当一个进程不能完全使用分给它的固定内存
            区域时就产生了内部碎片，通常内部碎片难以完全避免。
          2、外部碎片是由于某些未分配的连续内存区域太小，以致于不能满足任意进程的内存分
            配请求，从而不能被进程利用的内存区域。

      现在普通内存采用的段页式内存分配方式就是将进程的内存区域分为不同的段，然后将每一段
      由多个固定大小的页组成。通过页表机制，使段内的页可以不必连续处于同一内存区域，从而
      减少了外部碎片，然而同一页内仍然可能存在少量的内部碎片，只是一页的内存空间就比较
      小，从而使可能的内存碎片也减少。
</pre>

<pre>
如何解决同时存在的对象创建和对象回收问题？

      垃圾回收线程GC是回收内存的，而程序运行线程则是消耗和分配内存的，一个回收内存，一个
      分配内存，从这个点看两者是矛盾的。

      解决办法一、从现有的垃圾回收方式中，要进行垃圾回收前，一般都需要暂停整个应用（即：
         暂停内存分配），然后进行垃圾回收，回收完成后再继续应用。这种方式是最直接的，而
         且最有效的解决两种矛盾的方式。

      缺点：当堆空间支持增大时，垃圾回收的时间也将相应的持续增大，对应应用暂停的时间也会
         相应增大。一些相应时间要求很高的应用，比如最大暂停时间要求是好几百秒，那么当堆
         空间大于几个G时，就很有可能超过这个限制。

      解决方法二：使用并发垃圾回收算法，使用这种算法，垃圾回收线程与程序运行线程同时
                 运行，在这种方式下，解决了暂停的问题。

      缺点：因为需要在新生成对象的同时又要回收对象，算法复杂性会大大增加，系统的处理能
           力也会相应降低，同时“碎片”问题将会比较难以解决。
</pre>

<pre>
JVM中最大堆大小有没有限制
</pre>

<pre>
如何进行JVM调优？有哪些方法？
</pre>

<pre>
如何理解内存泄漏问题？有哪些情况会导致内存泄露？如何解决？

      内存溢出：
              1）内存泄漏的堆积最终会导致内存溢出
              2）内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出。
              3）内存泄漏是指你向系统申请分配内存进行使用，可是使用完了以后却不归还，结果你申请的那块内存你自己也不能再
                 访问，而系统也不能再次将它分配给需要的程序，就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，
                 把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法给任何人使用，也无法被垃圾回收期回收，因为找
                 不到他的任何信息。
              5）内存溢出：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉到地上不能吃了，这就是溢出，比方说栈：
                 栈满时再做进栈必定产生空间溢出，叫上溢，栈空时，再做退栈也产生空间溢出，叫做下溢，就是分配的内存不足以
                 放下数据项序列称为内存溢出。

      由于java的JVM引入了垃圾回收机制，垃圾回收器会自动回收不再使用的对象，了解JVM回收机制的都知道JVM是使用引用计数法和
      可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。那么对于这种情况下，由于代码的实现不
      同就会出现很多种内存泄漏问题（让JVM误以为此对象还在引用中，无法回收，造成内存泄漏）

      1：静态集合类
         如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不
         能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但
         是因为长生命周期对象持有它的引用而导致不能被回收。
      2:各种连接
         如数据库连接、网络连接和IO连接等。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用
         close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，
         对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。
      3:变量不合理的作用域
         一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，
        很有可能导致内存泄漏的发生。
      5:内部类持有外部类
        如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使
        用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。
      6:改变哈希值
        当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与
        最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去
        HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露
</pre>

<pre>
从分布式系统部署角度考虑，分哪几层？

      1）通信层
         这个任务包括设计适当的网络间进程通信机制，一些样例机制：远程过程调用RPC，远程
         对象调用ROI，面向流的通信和面向信息的通信，底层通信机制的实现。
      2）进程
         
      3）命名
         为了透明和可扩展的方式来定位资源的进程，设计一个名字分配标识符和地址是必不可少
         的。
      5）同步和互斥
      6）数据存储于访问
      7）一致性与副本
      8）容错
      9）安全
      10）API透明
      11）可扩展性与模块化
</pre>

<pre>
什么是著名的拜占庭将军问题？

      起源
           
         拜占庭位于如今的土耳其的伊斯坦布尔，是东罗马帝国的首都。由于当时拜占庭罗马帝国国
         土辽阔，为了防御目的，因此每个军队都分隔很远，将军与将军之间只能靠信差传消息。 
         在战争的时候，拜占庭军队内所有将军和副官必须达成一致的共识，决定是否有赢的机会
         才去攻打敌人的阵营。但是，在军队内有可能存有叛徒和敌军的间谍，左右将军们的决定又
         扰乱整体军队的秩序。在进行共识时，结果并不代表大多数人的意见。这时候，在已知有成
         员谋反的情况下，其余忠诚的将军在不受叛徒的影响下如何达成一致的协议，拜占庭问题
         就此形成。
</pre>

<pre>
为什么说TCP/IP协议是不可靠的？

      IP协议是无连接的，因此其传输是不可靠的

      不可靠：
            是指不能保证IP数据报能成功到达目的地，是一种尽力而为的传输服务，路由器对
            IP报错误处理方式是丢包，并发送ICMP给源地址。

      无连接：
            是指IP并不维护任何关于后续数据报的状态信息。每个数据报的处理是相互独立的。
</pre>

<pre>
怎么理解强一致性、单调一致性和最终一致性？
</pre>

<pre>
分布式系统设计你会考虑哪些策略？
</pre>

<pre>
什么是Lease租约机制？

      大多数数据分布方式都会有一个瓶颈问题----中心服务器存储维护者元数据，系统中的其他节
      点通过访问它读取，修改元数据，再这样，中心服务器节点的性能就很容易成为系统的瓶颈，
      解决方法有多种，你可能会搭建一个集群专门存储元数据，并对外进行读写，但这样又要涉及
      到一致性问题。

      Lease机制---为了解决上面的问题

      为了解决上面的性能瓶颈，lease机制设计了一套cache系统，在各个节点上cache元数据信
      息。

      基本原理：中心服务器在向各节点发送数据时同时向节点颁发一个lease.每个lease具有一个
      有效期,和信用卡上的有效期类似,lease上的有效期通常是一个明确的时间点,例如
      12:00:10,一旦真实时间超过这个时间点,则lease过期失效。在lease的有效期内,中心服务
      器保证不会修改对应数据的值。因此,节点收到数据和lease后,将数据加入本地Cache,一旦对
      应的lease超时,节点将对应的本地cache数据删除。中心服务器在修改数据时,首先阻塞所有新
      的读请求,并等待之前为该数据发出的所有lease超时过期,然后修改数据的值。

      上述机制可以保证各个节点上的cache与中心服务器上的中心始终一致。这是因为中心服务器
      节点在发送数据的同时授予了节点对应的lease,在lease有效期内,服务器不会修改数据,从
      而客户端节点可以放心的在lease有效期内cache数据。上述lease机制可以容错的关键是:服
      务器一旦发出数据及lease,无论客户端是否收到,也无论后续客户端是否宕机,也无论后续网络
      是否正常, 服务器只要等lease超时,就可以保证对应的客户端节点不会再继续cache数据,从
      而可以放心的修改数据而不会破坏cache的一致性。

      不难发现上面的机制有性能和可用性上的问题，但也容易优化。

      优化点一：
              服务器在修改元数据时首先要阻塞读请求并等待lease超时，这是为了防止发出新
              的lease从而引起活锁。优化方法很简单：进入修改流程后，我们对读请求只返回数
              据，不颁发lease。进一步优化，我们可以颁发lease,但有效期设置为已发出到
              lease的最大有效期。这样，客户端节点可以继续缓存元数据，并且不会造成活锁。
              不过，实际情况中，第一种优化就足够了。因为等待超时的时间会被优化点二大大减少。

      优化点二：
              服务器在修改元数据时需要等待所有的lease过期超时,从而造成修改元数据的操作
              时延大大增大。优化的方法是,在等待所有的lease过期的过程中,服务器主动通知各
              个持有lease的节点放弃lease并清除cache中的数据,如果服务器收到客户端返回
              的确认放弃lease的消息, 则服务器不需要在等待该lease超时。该过程中,如果因
              为异常造成服务器通知失败或者客户端节点发送应答消息失败,服务器只需依照原本
              的流程等待lease超时即可,而不会影响协议的正确性。

      优化点三：
              Lease机制依赖于有效期（常选择的 lease 时长是10秒级别）,这就要求颁发者和
              接收者的时钟是同步的。一方面,如果颁发者的时钟比接收者的时钟慢,则当接收者认
              为lease已经过期的时候,颁发者依旧认为lease有效。接收者可以用在lease到期前
              申请新的lease的方式解决这个问题。另一方面,如果颁发者的时钟比接收者的时钟
              快,则当颁发者认为lease已经过期的时候,接收者依旧认为lease有效,颁发者可能
              将lease颁发给其他节点,造成承诺失效,影响系统的正确性。对于这种时钟不同步,
              实践中的通常做法是将颁发者的有效期设置得比接收者的略大,只需大过时钟误差就
              可以避免对lease的有效性的影响。
</pre>

<pre>
JDBC编程有哪些不足之处，Mybatis是如何解决这些问题的
      1）数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可
         解决此问题。
         解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接。
      2）Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变
         java代码。
         解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。
      3）向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需
         要和参数一一对应。
         解决： Mybatis自动将java对象映射至sql语句。
      5）对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记
         录封装成pojo对象解析比较方便。
         解决：Mybatis自动将sql执行结果映射至java对象。
</pre>

<pre>
MyBatis编程步骤是什么样的？

     ① 创建SqlSessionFactory
     ② 通过SqlSessionFactory创建SqlSession
     ③ 通过sqlsession执行数据库操作
</pre>

<pre>
使用MyBatis的mapper接口调用时有哪些要求？

     ① Mapper接口方法名和mapper.xml中定义的每个sql的id相同

     ② Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同

     ③ Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同

     ④ Mapper.xml文件中的namespace即是mapper接口的类路径。
</pre>

<pre>
简单的说一下MyBatis的一级缓存和二级缓存？

     Mybatis首先去缓存中查询结果集，如果没有则查询数据库，如果有则从缓存取出返回结果集
     就不走数据库。Mybatis内部存储缓存使用一个HashMap，key为hashCode+sqlId+Sql语句。
     value为从查询出来映射生成的java对象

     Mybatis的二级缓存即查询缓存，它的作用域是一个mapper的namespace，即在同一个
     namespace中查询sql可以从缓存中获取数据。二级缓存是可以跨SqlSession的。
</pre>

![](https://i.imgur.com/5chRUHF.jpg)

<pre>
MyBatis架构:

      Configuration
          MyBatis所有的配置信息都保存在Configuration对象之中，配置文件中的大部分配置
          都会存储到该类中
      SqlSession 
          作为MyBatis工作的主要顶层API，表示和数据库交互时的会话，完成必要数据库增删改查功能
      Executor 
          MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护
      StatementHandler
          封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数等
      ParameterHandler
          负责对用户传递的参数转换成JDBC Statement 所对应的数据类型
      ResultSetHandler
          负责将JDBC返回的ResultSet结果集对象转换成List类型的集合
      TypeHandler
          负责java数据类型和jdbc数据类型(也可以说是数据表列类型)之间的映射和转换
      MappedStatement
          MappedStatement维护一条<select|update|delete|insert>节点的封装
      SqlSource 
          负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到
          BoundSql对象中，并返回
      BoundSql
          表示动态生成的SQL语句以及相应的参数信息
</pre>

<pre>
#{} ${}

      但是 #{} 和 ${} 在预编译中的处理是不一样的。#{} 在预处理时，会把参数部分用一个占位符 ? 代替，变成如下的 sql 语句：
                    select * from user where name = ?;
      而 ${} 则只是简单的字符串替换，在动态解析阶段，该 sql 语句会被解析成
                    select * from user where name = 'zhangsan';

      以上，#{} 的参数替换是发生在 DBMS 中，而 ${} 则发生在动态解析过程中。
</pre>

<pre>
一般来说子查询和关联子表的性能，相对来说 关联表要好一些。

为什么呢？

主要在于优化器更加倾向于去优化 关联查询，且关联查询相对来说更易理解，语句也相对简单，所
以优化效果比较好，能生成较优的执行计划。

但是，这个也不确定，性能是否好，还是要看优化器生成的执行计划，如果子查询生成的执行计划
更好，那么就会更快。
</pre>

