# JAVAExt2Tree
Java高级基础技术研究


<pre>
Java中如何正确的终止线程：

      1）Thread.stop()
         一个被废弃了的方法，不被推荐使用的原因是stop方法太过于暴力，强行把执行到一半的线
         程终止，并且会立即释放这个线程所有的锁，会破坏了线程中引用对象的一致性。

         例如在数据库中维护着一张用户表，记录了用户ID和用户名，使用Thread多线程写入两条记录:

             如果在记录1写到一半的时候被stop结束了，就可能出现各种奇怪的现象：

             记录1被记录2覆盖，没有任何数据留下。

             记录1只有一半，即只有ID，而NAME为空。

      使用判断标志位的方法中断线程：
          那如果的确有中断线程的需求,我们需要怎么做呢？一般我们马上就会想到设置标志位的方
          法,即在线程中执行每一个步骤之前都判断一下是否需要退出线程:
          
          其实Thread类早就帮我们实现了这个中断标志了。与Thread中断相关的方法有下面三个:
               public void Thread.interrupt() //线程中断

               public native boolean Thread.isInterrupted() //判断是否被中断

               public static native boolean Thread.interrupted() //判断是否中断,并清除当前中断状态

          需要提醒一下的是Thread.interrupt()方法并不会像Thread.stop()方法一样立即结束
          线程,它只是设置了一个中断标志,需要在代码实现中去手动判断这个标志并且推出。

          Thread.interrupt的优点
              使用Thread.interrupt去中断线程除了可以免去自己实现标志位的烦恼之外,还可以中断sleep和wait中的线程。

              需要注意的是如果sleep方法由于中断而抛出异常，此时，它会清除中断标记。所以在
              catch到这个异常的时候需要再次设置中断标记：
</pre>

<pre>
内连接 左连接 右连接 全连接

      left join:  返回包括左表中的所有记录和右表中连接字段相等的记录
      right join :返回右表中的所有记录和左表中和连接字段相等的记录
      inner join: 只返回两个表中连接字段相等的行
      full join: 返回左右表中所有的记录和左右表中连接字段相等的记录
</pre>

![](https://i.imgur.com/AZNAwBy.png)

![](https://i.imgur.com/Z6ZQYN9.png)

<pre>
SQL注入的原理

      解决方法：
              1）永远不要信任用户的输入，要对用户的输入进行校验，能够通过正则表达式，或
                 限制长度，对单引号和双-进行转换等。
              2）永远不要使用动态拼装SQL,能够使用参数化的SQL或者直接使用存储过程进行数据
                 查询存取
              3）永远不要使用管理员权限的数据库连接，为每一个应用使用单独的权限有限的数据库连接。
              5）不要把机密信息明文存放，请加密或者hash掉password和敏感的信息
              6）应用的异常信息应该给出尽可能少的提示，最好使用自己定义的错误信息对原始
                 错误信息进行包装，把异常的信息存放在独立的表中。

      但使用正則表達式仅仅能防范一些常见或已知SQL Injection方式，并且每当发现有新的攻击方
      式时，都要对正則表達式进行改动，这但是吃力不讨好的工作。
  
      可以通过參数化存储过程进行数据查询存取。

      大家看到当我们试图在URL中嵌入恶意的SQL语句时，參数化存储过程已经帮我们校验出传递给数
      据库的变量不是整形，并且使用存储过程的优点是我们还能够非常方便地控制用户权限，我们能
      够给用户分配仅仅读或可读写权限。

      但我们想想真的有必要每一个数据库操作都定义成存储过程吗？并且那么多的存储过程也不利于
      日常的维护。           
</pre>

<pre>
10万并发的服务器应该怎么构建？

      首先要确认你的10w并发服务器，是长连接型的，如即时通讯；还是短连接型的，如网站？

      如果是短连接型，首推仍然是线程池；因为这种情况下连接会很多、切换很快，所以没必要去维护
      连接，想想银行大厅的前台窗口排队叫号，窗口忙得很如果还同时照顾几个客户那不疯了？

      如果是长连接型，首推是NIO模型；因为这种情况下保持连接很重要，但线程并不忙，想想医院住
      院部的病人，大部分时间躺在床上就行了，一个护士就可以搞定好多病人了；mina提供了比较好
      的封装。
</pre>

<pre>
缓存击穿有哪些方案解决?
</pre>

<pre>
dubbo如何一条链接并发多个调用
</pre>

<pre>
Override和Overload的区别，分别用在什么场景

      override是方法覆盖，用在父子类中，是方法名字相同，参数列表也相同，声明形式都相同，但
      是子类方法的权限不允许小于父类，不允许抛出比父类更多的异常。调用子类的方法与父类的同名
      方法无关，在子类中完全覆盖了父类的方法。

      overload是方法重载，用在同一个类中，是几个方法的名字相同，返回值相同，但是参数列表不
      同，举例来说就像构造函数，可以有多个构造函数，并且每个的参数列表都不同，这样可以用多
      种方式构造对象。
</pre>

<pre>
类序列化时类的版本号的用途，如果没有指定一个版本号，系统是怎么处理的？如果加了字段会怎么样？

      Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反
      序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的
      serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序
      列化版本不一致的异常。

      serialVersionUID 用来表明类的不同版本间的兼容性。有两种生成方式： 
          1) 一个是默认的1L；
          2) 另一种是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段 。 在JDK
          中，可以利用JDK的bin目录下的serialver.exe工具产生这个serialVersionUID 的值

          对于Test.class，
               执行命令： 
                       serialver Test   
               这时JVM（java虚拟机）会生成一个哈希字段。
</pre>

<pre>
InnoDB读不加锁
</pre>

<pre>
mybatis如何映射表结构
</pre>

<pre>
static加锁
</pre>

<pre>
sql语句各种条件的执行顺序，如select， where， order by， group by
</pre>

<pre>
mysql是如何实现事务的
</pre>

<pre>
hashmap如果只有一个写其他全读会出什么问题
</pre>

<pre>
如何手动触发全量回收垃圾，如何立即触发垃圾回收
</pre>

<pre>
ConcurrentHashmap的锁是如何加的？是不是分段越多越好
</pre>

<pre>
mysql的行级锁加在哪个位置
</pre>

<pre>
遍历hashmap的三种方式
</pre>

<pre>
定时器用什么做的
</pre>

<pre>
用过spring的线程池还是java的线程池？
</pre>

<pre>
IO会阻塞吗？readLine是不是阻塞的
</pre>

<pre>
spring的监听器。
</pre>

<pre>
spring的bean配置的几种方式
</pre>

<pre>
aop的底层实现，动态代理是如何动态，假如有100个对象，如何动态的为这100个对象代理
</pre>

<pre>
一万个人抢100个红包，如何实现（不用队列），如何保证2个人不能抢到同一个红包，可用分布式锁
</pre>

<pre>
线程的阻塞的方式
</pre>

<pre>
用hashmap实现redis有什么问题（死锁，死循环，可用ConcurrentHashmap）
</pre>

<pre>
nginx的请求转发算法，如何配置根据权重转发
</pre>

<pre>
junit用法，before,beforeClass,after, afterClass的执行顺序
</pre>

